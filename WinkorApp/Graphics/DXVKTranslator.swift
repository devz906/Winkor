import Foundation

// DXVK Translator: Manages the DirectX to Vulkan translation layer
// In the full pipeline: DirectX (game) → DXVK → Vulkan → MoltenVK → Metal → iOS GPU
// DXVK replaces d3d9.dll, d3d10.dll, d3d11.dll, dxgi.dll with Vulkan-based implementations

class DXVKTranslator {
    
    enum DXVKVersion: String, CaseIterable {
        case v2_3_1 = "2.3.1"
        case v2_3 = "2.3"
        case v2_2 = "2.2"
        case v2_1 = "2.1"
        case v2_0 = "2.0"
        case v1_10_3 = "1.10.3"
        
        var description: String {
            switch self {
            case .v2_3_1: return "Latest - Best compatibility and performance"
            case .v2_3: return "Stable - Recommended for most games"
            case .v2_2: return "Stable - Good fallback"
            case .v2_1: return "Older - For compatibility"
            case .v2_0: return "Legacy - Wider game support"
            case .v1_10_3: return "Legacy - For very old games"
            }
        }
    }
    
    struct DXVKConfig: Codable {
        var enableHUD: Bool = false
        var hudElements: [String] = ["fps", "frametimes"]
        var maxFrameLatency: Int = 1
        var enableAsync: Bool = true
        var enableShaderCache: Bool = true
        var shaderCachePath: String = ""
        var enableNVAPI: Bool = false
        var numCompilerThreads: Int = 0  // 0 = auto
        var forceD3D9On12: Bool = false
        var enableDXVKStateCache: Bool = true
        
        func toConfigString() -> String {
            var config = "# DXVK Configuration - Generated by Winkor\n\n"
            
            config += "# Frame latency\n"
            config += "dxgi.maxFrameLatency = \(maxFrameLatency)\n"
            config += "d3d9.maxFrameLatency = \(maxFrameLatency)\n\n"
            
            config += "# Async shader compilation\n"
            config += "dxvk.enableAsync = \(enableAsync ? "True" : "False")\n\n"
            
            config += "# Shader cache\n"
            config += "dxvk.enableStateCache = \(enableDXVKStateCache ? "True" : "False")\n"
            if !shaderCachePath.isEmpty {
                config += "dxvk.stateCachePath = \(shaderCachePath)\n"
            }
            config += "\n"
            
            config += "# NVAPI hack\n"
            config += "dxgi.nvapiHack = \(enableNVAPI ? "True" : "False")\n\n"
            
            if numCompilerThreads > 0 {
                config += "# Compiler threads\n"
                config += "dxvk.numCompilerThreads = \(numCompilerThreads)\n\n"
            }
            
            config += "# Dynamic resources caching\n"
            config += "d3d11.cachedDynamicResources = \"a\"\n\n"
            
            config += "# Disable unmapped memory tracking for performance\n"
            config += "d3d11.zeroWorkgroupMemory = False\n"
            
            return config
        }
        
        func toEnvVars() -> [String: String] {
            var vars: [String: String] = [:]
            
            if enableHUD {
                vars["DXVK_HUD"] = hudElements.joined(separator: ",")
            } else {
                vars["DXVK_HUD"] = "0"
            }
            
            if enableAsync {
                vars["DXVK_ASYNC"] = "1"
            }
            
            vars["DXVK_LOG_LEVEL"] = "none"
            vars["DXVK_LOG_PATH"] = "none"
            
            return vars
        }
    }
    
    // The DLLs that DXVK overrides
    static let dxvkDLLs = [
        "d3d9.dll",      // DirectX 9
        "d3d10core.dll", // DirectX 10
        "d3d11.dll",     // DirectX 11
        "dxgi.dll"       // DXGI (shared infrastructure)
    ]
    
    // VKD3D-Proton DLLs for DirectX 12
    static let vkd3dDLLs = [
        "d3d12.dll",
        "d3d12core.dll"
    ]
    
    var config = DXVKConfig()
    
    func installDXVK(version: DXVKVersion, to containerPrefix: URL) throws {
        let system32 = containerPrefix.appendingPathComponent("drive_c/Windows/System32")
        let syswow64 = containerPrefix.appendingPathComponent("drive_c/Windows/SysWOW64")
        
        let docs = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!
        let dxvkSource64 = docs.appendingPathComponent("drivers/dxvk/x64")
        let dxvkSource32 = docs.appendingPathComponent("drivers/dxvk/x32")
        
        // Copy 64-bit DXVK DLLs to System32
        for dll in Self.dxvkDLLs {
            let src = dxvkSource64.appendingPathComponent(dll)
            let dst = system32.appendingPathComponent(dll)
            
            if FileManager.default.fileExists(atPath: src.path) {
                try? FileManager.default.removeItem(at: dst)
                try FileManager.default.copyItem(at: src, to: dst)
                print("[DXVK] Installed 64-bit \(dll)")
            }
        }
        
        // Copy 32-bit DXVK DLLs to SysWOW64
        for dll in Self.dxvkDLLs {
            let src = dxvkSource32.appendingPathComponent(dll)
            let dst = syswow64.appendingPathComponent(dll)
            
            if FileManager.default.fileExists(atPath: src.path) {
                try? FileManager.default.removeItem(at: dst)
                try FileManager.default.copyItem(at: src, to: dst)
                print("[DXVK] Installed 32-bit \(dll)")
            }
        }
        
        // Write DXVK config
        let configPath = containerPrefix.appendingPathComponent("dxvk.conf")
        try config.toConfigString().write(to: configPath, atomically: true, encoding: .utf8)
        print("[DXVK] Config written to \(configPath.path)")
    }
    
    func installVKD3D(to containerPrefix: URL) throws {
        let system32 = containerPrefix.appendingPathComponent("drive_c/Windows/System32")
        let docs = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!
        let vkd3dSource = docs.appendingPathComponent("drivers/vkd3d/x64")
        
        for dll in Self.vkd3dDLLs {
            let src = vkd3dSource.appendingPathComponent(dll)
            let dst = system32.appendingPathComponent(dll)
            
            if FileManager.default.fileExists(atPath: src.path) {
                try? FileManager.default.removeItem(at: dst)
                try FileManager.default.copyItem(at: src, to: dst)
                print("[VKD3D] Installed \(dll)")
            }
        }
    }
    
    // MARK: - DirectX Version Detection
    
    enum DirectXVersion: String {
        case dx8 = "DirectX 8"
        case dx9 = "DirectX 9"
        case dx10 = "DirectX 10"
        case dx11 = "DirectX 11"
        case dx12 = "DirectX 12"
        case opengl = "OpenGL"
        case vulkan = "Vulkan"
        case unknown = "Unknown"
    }
    
    func detectGraphicsAPI(imports: [PELoader.ImportEntry]) -> DirectXVersion {
        for imp in imports {
            let dll = imp.dllName.lowercased()
            if dll.contains("d3d12") { return .dx12 }
            if dll.contains("d3d11") { return .dx11 }
            if dll.contains("d3d10") { return .dx10 }
            if dll.contains("d3d9") { return .dx9 }
            if dll.contains("d3d8") { return .dx8 }
            if dll.contains("opengl32") { return .opengl }
            if dll.contains("vulkan") { return .vulkan }
        }
        return .unknown
    }
    
    func recommendedWrapper(for dxVersion: DirectXVersion) -> String {
        switch dxVersion {
        case .dx8: return "D8VK (DirectX 8 → Vulkan)"
        case .dx9: return "DXVK (DirectX 9 → Vulkan)"
        case .dx10: return "DXVK (DirectX 10 → Vulkan)"
        case .dx11: return "DXVK (DirectX 11 → Vulkan)"
        case .dx12: return "VKD3D-Proton (DirectX 12 → Vulkan)"
        case .opengl: return "VirGL (OpenGL → Metal) or Native"
        case .vulkan: return "MoltenVK (Vulkan → Metal)"
        case .unknown: return "DXVK (Default)"
        }
    }
}
